


<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">

  <title>Node.js源码阅读笔记</title>
  
  

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://cattail.me/tech/2014/10/16/nodejs-source-reading-note.html">

  <!-- Fonts -->
  <link href='//fonts.lug.ustc.edu.cn/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
  <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:900,300' rel='stylesheet' type='text/css'>

  <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-41494270-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>


  <body>

    <div class="site-wrap">
      <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">猫尾博客</a>

    <nav class="site-nav">
        <a class="page-link" href="/lab">Lab</a>
        <a class="page-link" href="/feed.xml">RSS</a>
        <a class="page-link" href="/about">About</a>
    </nav>

  </div>

</header>


      <div class="body">
        <div class="wrapper">
          <div class="post yue">

            <header class="post-header">
              <h1 class="post-title">Node.js源码阅读笔记</h1>
              <span class="post-meta">
                Oct 16, 2014
              </span><br />
              <span class="post-meta small">
                5 minute read
              </span>
            </header>

            <article class="post-content">
              <p>本文通过阅读Node.js(<a href="https://github.com/joyent/node/tree/v0.11.9">版本0.11.9</a>)的代码, 试图理解两个问题</p>

<ul>
  <li>C++和JS是如何交互的</li>
  <li>异步是如何实现的, event loop在其中充当什么角色</li>
</ul>

<p>目录</p>

<ul>
  <li><a href="#两个问题">两个问题</a></li>
  <li><a href="#c++和javascript交互">C++和Javascript交互</a></li>
  <li><a href="#node.js初始化">Node.js初始化</a>
    <ul>
      <li><a href="#node.js模块">Node.js模块</a></li>
      <li><a href="#process.binding">process.binding</a></li>
      <li><a href="#模块小结">模块小结</a></li>
    </ul>
  </li>
  <li><a href="#异步实现">异步实现</a>
    <ul>
      <li><a href="#追踪fs.readfile回调">追踪fs.readFile回调</a></li>
      <li><a href="#创建运行event-loop">创建运行event loop</a></li>
      <li><a href="#深入libuv">深入libuv</a></li>
      <li><a href="#异步小结">异步小结</a></li>
    </ul>
  </li>
  <li><a href="#总结">总结</a></li>
  <li><a href="#相关参考">相关参考</a></li>
</ul>

<h2 id="section">两个问题</h2>

<h3 id="section-1">最大调用栈</h3>
<p>如果直接调用一下代码, 会造成调用栈过深</p>

<pre><code class="language-javascript">function foo() {
    foo();
}
foo();
// Maximum call stack size exceeded
</code></pre>

<p>然而, 将递归调用放到异步回调中, 就避免了调用栈过深</p>

<pre><code class="language-javascript">function foo() {
    setTimeout(foo, 0);
}
foo();
// all right. browser never block, code execute normally.
</code></pre>

<h3 id="section-2">队列优先级</h3>
<p>下面是一个文件读取操作, 多次试验, 输出的文件平均读取耗时为40mm</p>

<pre><code class="language-javascript">var start = Date.now();

fs.readFile("data.txt", function() {
    console.log(Date.now() - start);
});
// 35, 38, 40, 37, 42
</code></pre>

<p>我们设定两个计时器, 一个比文件读取时间短(0), 另一个要长(100), 最后输出结果在注释中</p>

<pre><code class="language-javascript">var fs = require('fs');

var start = Date.now();

setTimeout(function() {
    console.log('First timer');
}, 0);

fs.readFile("data.txt", function() {
    console.log('Async Operation', Date.now() - start);
});

setTimeout(function() {
    console.log('Second timer');
}, 100);

// First timer 12
// Async Operation 36
// Second timer 108
</code></pre>

<p>这样的结果我们是能够理解的, 第一个计时器最快完成(0mm), 然后文件读取完成(37mm), 最后一个计时器最后完成.</p>

<p>但是, 如果像下面代码, 我们使用循环阻塞整个进程, 直到所有任务都完成后, 在执行回调, 结果是怎样呢?</p>

<pre><code class="language-javascript">var fs = require('fs');

var start = Date.now();

setTimeout(function() {
    console.log('First timer', Date.now() - start);
}, 0);

fs.readFile("data.txt", function() {
    console.log('Async Operation', Date.now() - start);
});

setTimeout(function() {
    console.log('Second timer', Date.now() - start);
}, 100);

while(1) {
    if ((Date.now() - start) &gt; 200) {
        break;
    }
}

// First timer 212
// Second timer 213
// Async Operation 238
</code></pre>

<p>结果先执行两个计时器, 最后执行IO操作. 下面是一个类似的浏览器上的例子</p>

<iframe width="100%" height="300" src="https://jsfiddle.net/cattail/bkghxdfr/8/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>为了理解这两个问题, 我们需要理解event loop背后的原理, 回答一些问题 — 1) 多线程? 2) 多堆栈? 3) 多队列?</p>

<h2 id="cjavascript">C++和Javascript交互</h2>
<p>通过v8源码的示例<a href="https://github.com/joyent/node/blob/v0.11.9/deps/v8/samples/process.cc">process.cc</a>和<a href="https://github.com/joyent/node/blob/v0.11.9/deps/v8/samples/count-hosts.js">count-hosts.js</a>, 我们可以了解C++和Javascript代码是如何进行交互的.</p>

<p>通过在C++代码中使用v8引擎提供的接口, 可以在Javascript运行上下文中插入使用C++定义的变量(或函数); 同时, 也可以取出Javascript在此上下文中定义的变量(或函数等), 在C++代码中执行.</p>

<p><strong>在Javascript代码中使用通过C++定义的函数</strong></p>

<p>首先创建全局对象, 用于存放build-in函数<code>log</code> <a href="https://github.com/joyent/node/blob/v0.11.9/deps/v8/samples/process.cc#L164">source</a></p>

<pre><code class="language-cpp">Handle&lt;ObjectTemplate&gt; global = ObjectTemplate::New();
global-&gt;Set(String::New("log"), FunctionTemplate::New(LogCallback));
</code></pre>

<p>在Javascript中, 就可以使用log函数输出日志 <a href="https://github.com/joyent/node/blob/v0.11.9/deps/v8/samples/count-hosts.js#L32">source</a></p>

<pre><code class="language-cpp">log("Processing " + request.host + request.path + " from " + request.referrer + "@" + request.userAgent);
</code></pre>

<p><strong>在C++中获得使用Javascript定义的函数</strong></p>

<p>在count-hosts.js中定义全局函数Process</p>

<pre><code class="language-cpp">function Process(request) { ... }
</code></pre>

<p>在process.cc中, 先取出该函数 <a href="https://github.com/joyent/node/blob/v0.11.9/deps/v8/samples/process.cc#L189">source</a></p>

<pre><code class="language-cpp">Handle&lt;String&gt; process_name = String::New("Process");
Handle&lt;Value&gt; process_val = context-&gt;Global()-&gt;Get(process_name);
Handle&lt;Function&gt; process_fun = Handle&lt;Function&gt;::Cast(process_val);
</code></pre>

<p>之后再调用它</p>

<pre><code class="language-cpp">const int argc = 1;
Handle&lt;Value&gt; argv[argc] = { request_obj };
v8::Local&lt;v8::Function&gt; process = v8::Local&lt;v8::Function&gt;::New(GetIsolate(), process_);
Handle&lt;Value&gt; result = process-&gt;Call(context-&gt;Global(), argc, argv);
</code></pre>

<h2 id="nodejs">Node.js初始化</h2>

<p>为了理解event loop的实现, 首先要对Node.js初始化和模块有所了解.</p>

<p>Node.js的初始化调用链是这样的, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node_main.cc#L64">main</a> -&gt; <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3224">Start</a> -&gt; <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3177">CreateEnvironment</a> -&gt; <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L2520">Load</a>, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3224">Start</a>过程中启用了event loop</p>

<pre><code class="language-cpp">int Start(int argc, char** argv) {
    ...
    Environment* env =
        CreateEnvironment(node_isolate, argc, argv, exec_argc, exec_argv);
    ...
*    uv_run(env-&gt;event_loop(), UV_RUN_DEFAULT);
    ...
}
</code></pre>

<p><a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L2520">node:Load</a>加载了<a href="https://github.com/joyent/node/blob/v0.11.9/src/node.js">node.js</a>, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.js">node.js</a>是第一个被加载的Javascript文件, 它负责初始化Node.js的全局变量和函数, 如setTimeout, nextTick等.</p>

<h3 id="nodejs-1">Node.js模块</h3>
<p>Node.js中, 模块是通过<code>require</code>来加载的, 其背后实现代码在<a href="https://github.com/joyent/node/blob/v0.11.9/src/node.js#L968">NativeModule.require</a>中.</p>

<p><code>NativeModule.require</code>首先检测模块是否在缓存中,</p>

<pre><code class="language-javascript">NativeModule.require = function(id) {
    ...
    var cached = NativeModule.getCached(id);
    if (cached) {
        return cached.exports;
    }
    ...
};
</code></pre>

<p>如果没有则读取该模块文件内容, 并调用<code>runInThisContext</code>执行Javascript模块代码</p>

<pre><code class="language-javascript">NativeModule.require = function(id) {
    ...
    var nativeModule = new NativeModule(id);

    nativeModule.cache();
    nativeModule.compile();

    return nativeModule.exports;
};

NativeModule.prototype.compile = function() {
    var source = NativeModule.getSource(this.id);
    source = NativeModule.wrap(source);

    var fn = runInThisContext(source, { filename: this.filename });
    fn(this.exports, NativeModule.require, this, this.filename);

    this.loaded = true;
};
</code></pre>

<p>那么<code>runInThisContext</code>是怎样实现的呢?</p>

<pre><code class="language-javascript">var ContextifyScript = process.binding('contextify').ContextifyScript;
function runInThisContext(code, options) {
    var script = new ContextifyScript(code, options);
    return script.runInThisContext();
}
</code></pre>

<p>稍后将介绍<code>process.binding</code>的实现. 通过grep代码, 在<a href="https://github.com/joyent/node/blob/v0.11.9/src/node_contextify.cc">node_contextify.cc</a>找到了<code>contextify</code>的C++实现.</p>

<p>可以预见, <code>process.binding</code>作为一个桥梁, 使用我们上面介绍C++和Javascript交互的技术, 使得Node.js可以调用C++中实现的代码.</p>

<h3 id="processbinding">process.binding</h3>
<p>我们可以在之前提到的Node.js初始化代码中，找到<code>process.binding</code>的实现.</p>

<p>在<a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3177">node:CreateEnvironment</a>过程中, 会初始化<code>process</code>对象, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L2472">设置<code>process.binding</code></a>方法</p>

<pre><code class="language-cpp">Environment* CreateEnvironment() {
  ...
  SetupProcessObject(env, argc, argv, exec_argc, exec_argv);
  ...
}

void SetupProcessObject() {
  ...
  NODE_SET_METHOD(process, "binding", Binding);
  ...
}
</code></pre>

<p><a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L1900">Binding</a>方法接受参数, 然后通过<a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L1924">调用<code>get_buildin_module</code></a>返回使用C++编写的模块</p>

<pre><code class="language-cpp">static void Binding(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  ...
  node_module_struct* mod = get_builtin_module(*module_v);
  if (mod != NULL) {
    exports = Object::New();
    // Internal bindings don't have a "module" object, only exports.
    assert(mod-&gt;register_func == NULL);
    assert(mod-&gt;register_context_func != NULL);
    Local&lt;Value&gt; unused = Undefined(env-&gt;isolate());
    mod-&gt;register_context_func(exports, unused, env-&gt;context());
    cache-&gt;Set(module, exports);
  } else if (!strcmp(*module_v, "constants")) {
    exports = Object::New();
    DefineConstants(exports);
    cache-&gt;Set(module, exports);
  } else if (!strcmp(*module_v, "natives")) {
    exports = Object::New();
    DefineJavaScript(exports);
    cache-&gt;Set(module, exports);
  } else {
    return ThrowError("No such module");
  }

  args.GetReturnValue().Set(exports);
}
</code></pre>

<p><a href="https://github.com/joyent/node/blob/v0.11.9/src/node_extensions.cc#L52">get_builtin_module</a>通过事先注册的模块列表<code>node_module_list</code>来加载模块, <code>node_module_list</code>是通过宏实现的.</p>

<p>在src/node_extensions.h中定义宏<a href="https://github.com/joyent/node/blob/v0.11.9/src/node_extensions.h#L33">NODE_EXT_LIST</a>, 其中包含了使用C++编写的模块</p>

<p>在src/node_extensions.cc中, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node_extensions.cc#L48">调用宏</a>, 展开过程中使用到得诸如<code>node_fs_module</code>变量则是在每个C++模块底部定义的</p>

<pre><code class="language-cpp">NODE_MODULE_CONTEXT_AWARE(node_contextify, node::InitContextify);
</code></pre>

<p>这个宏展开后的结果是</p>

<pre><code class="language-cpp">extern "C" {
    node::node_module_struct node_contextify_module = {
        13 , __null , __FILE__ , __null , ( node::InitContextify ), "node_contextify"}
    ;
};
</code></pre>

<p><code>get_builtin_module</code>中获取了C++模块后, 通过使用<code>register_context_func</code>模块自己制定的<a href="https://github.com/joyent/node/blob/v0.11.9/src/node_file.cc#L1059">注册函数</a>完成注册的步骤.</p>

<pre><code class="language-cpp">mod-&gt;register_context_func(exports, unused, env-&gt;context());
</code></pre>

<h3 id="section-3">模块小结</h3>
<p>Node.js使用C++来实现系统调用, 在每个C++模块底部都将该模块注册到一个全局队列中. 当这些模块被<code>require</code>时, 将检索全局队列, 初始化, 导出该模块.</p>

<p>如果你编写过Node.js <a href="http://nodejs.org/api/addons.html">C++ Addon</a>, 就会发现Addon也需要通过宏来注册自己.</p>

<h2 id="section-4">异步实现</h2>

<h3 id="fsreadfile">追踪fs.readFile回调</h3>
<p>为了追查异步调用的实现, 我们先从一个常用的异步方法<a href="https://github.com/joyent/node/blob/v0.11.9/lib/fs.js#L172">fs.readFile</a>开始,</p>

<p><code>fs.readFile</code>使用<a href="https://github.com/joyent/node/blob/v0.11.9/lib/fs.js#L413">fs.read</a>来读取数据, 并最终调用<code>binding.read</code></p>

<pre><code class="language-javascript">fs.read = function(fd, buffer, offset, length, position, callback) {
  ...
  binding.read(fd, buffer, offset, length, position, wrapper);
};
</code></pre>

<p>其中<code>binding</code>是这样定义的</p>

<pre><code class="language-javascript">var binding = process.binding('fs');
</code></pre>

<p>根据我们上节讲到得<code>process.binding</code>魔法, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node_file.cc">node_file.cc</a>为文件操作提供了最终实现.</p>

<p><code>fs.read</code>在<a href="https://github.com/joyent/node/blob/v0.11.9/src/node_file.cc">node_file.cc</a>中实现为<a href="https://github.com/joyent/node/blob/v0.11.9/src/node_file.cc#L803">Read</a>, 这个实现是对<code>read(2)</code>的一个包装.</p>

<p>在<code>Read</code>中, 获取了异步调用的回调函数, 并将其传入<code>ASYNC_CALL</code></p>

<pre><code class="language-cpp">static void Read(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
    ...
    cb = args[5];

    if (cb-&gt;IsFunction()) {
        ASYNC_CALL(read, cb, fd, buf, len, pos);
    } else {
        SYNC_CALL(read, 0, fd, buf, len, pos)
        args.GetReturnValue().Set(SYNC_RESULT);
    }
    ...
}
</code></pre>

<p>宏展开<code>async</code></p>

<pre><code class="language-cpp">Environment* env = Environment::GetCurrent(args.GetIsolate());
FSReqWrap* req_wrap = new FSReqWrap(env, "read" );
int err = uv_fs_read (env-&gt;event_loop(), &amp;req_wrap-&gt;req_, fd , buf , len , pos , After);
req_wrap-&gt;object()-&gt;Set(env-&gt;oncomplete_string(), cb );
req_wrap-&gt;Dispatched();
if (err &lt; 0) {
    uv_fs_t* req = &amp;req_wrap-&gt;req_;
    req-&gt;result = err;
    req-&gt;path = __null ;
    After(req);
}
args.GetReturnValue().Set(req_wrap-&gt;persistent());
</code></pre>

<p>在libuv中, <code>uv_fs_read</code>的定义是这样的,</p>

<pre><code class="language-cpp">UV_EXTERN int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,void* buf, size_t length, int64_t offset, uv_fs_cb cb);
</code></pre>

<p>它使用event loop的核心数据结构<code>loop</code>, 当文件读取操作完成后, 将会调用回调函数<code>cb</code>. 接下来我们来看看 libuv是如何实现完成事件调用函数的功能的.</p>

<h3 id="event-loop">创建运行event loop</h3>

<p>Node.js初始化过程中, <a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3177">CreateEnvironment</a>使用<code>uv_default_loop</code>创建了event loop中使用的核心数据结构<code>loop</code>, 在<a href="https://github.com/joyent/node/blob/v0.11.9/src/node.cc#L3224">node:Start</a>中通过<code>uv_run</code>启用event loop(见<a href="#node.js初始化">Node.js初始化</a>)</p>

<h3 id="libuv">深入libuv</h3>
<p>理解libuv分两条线索, 任务的提交和任务的处理.</p>

<p><strong>任务提交</strong></p>

<p>仍以文件读取为例, 上面已经讲到<code>uv_fs_read</code>会在文件可用时调用回调.</p>

<pre><code class="language-cpp">uv_fs_read (env-&gt;event_loop(), &amp;req_wrap-&gt;req_, fd , buf , len , pos , After);
</code></pre>

<p><code>uv_fs_read</code>是这样定义的(deps/uv/src/unix/fs.c)</p>

<pre><code class="language-cpp">int uv_fs_read() {
  ...
  do {
      if ((cb) != ((void*)0) ) {
*          uv__work_submit((loop), &amp;(req)-&gt;work_req, uv__fs_work, uv__fs_done);
          return 0;
      }
      else {
          uv__fs_work(&amp;(req)-&gt;work_req);
          uv__fs_done(&amp;(req)-&gt;work_req, 0);
          return (req)-&gt;result;
      }
  }
  ...
}
</code></pre>

<p>最后文件读取任务被插入任务队列, 等待线程池中线程空闲后执行,</p>

<p><a href="https://github.com/joyent/node/blob/v0.11.9/deps/uv/src/unix/threadpool.c#L156">source</a></p>

<pre><code class="language-cpp">void uv__work_submit() {
  uv_once(&amp;once, init_once);
  w-&gt;loop = loop;
  w-&gt;work = work;
  w-&gt;done = done;
  post(&amp;w-&gt;wq);
}

static void post(QUEUE* q) {
  uv_mutex_lock(&amp;mutex);
  QUEUE_INSERT_TAIL(&amp;wq, q);
  uv_cond_signal(&amp;cond);
  uv_mutex_unlock(&amp;mutex);
}

#define QUEUE_INSERT_TAIL(h, q)                                               \
  do {                                                                        \
    QUEUE_NEXT(q) = (h);                                                      \
    QUEUE_PREV(q) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(q) = (q);                                                 \
    QUEUE_PREV(h) = (q);                                                      \
  }                                                                           \
  while (0)
</code></pre>

<p><strong>任务处理</strong></p>

<p><code>uv_default_loop</code>创建并初始化了loop对象,</p>

<pre><code class="language-c">uv_loop_t* uv_default_loop(void) {
  if (default_loop_ptr != NULL)
    return default_loop_ptr;

  if (uv__loop_init(&amp;default_loop_struct, /* default_loop? */ 1))
    return NULL;

  default_loop_ptr = &amp;default_loop_struct;
  return default_loop_ptr;
}

static int uv__loop_init(uv_loop_t* loop, int default_loop) {
  ...
  memset(loop, 0, sizeof(*loop));
  RB_INIT(&amp;loop-&gt;timer_handles);
  QUEUE_INIT(&amp;loop-&gt;wq);
  QUEUE_INIT(&amp;loop-&gt;active_reqs);
  QUEUE_INIT(&amp;loop-&gt;idle_handles);
  QUEUE_INIT(&amp;loop-&gt;async_handles);
  QUEUE_INIT(&amp;loop-&gt;check_handles);
  QUEUE_INIT(&amp;loop-&gt;prepare_handles);
  QUEUE_INIT(&amp;loop-&gt;handle_queue);
  ...
}
</code></pre>

<p><code>uv_run</code>不断循环检测是否还有待处理任务, 如果有则执行该任务关联的回调; 如果没有待处理的任务, 程序就结束了.</p>

<p>在这里还可以看到, 对于<code>timer</code>和<code>io</code>任务队列的处理优先级是不同的.</p>

<pre><code class="language-c">int uv_run(uv_loop_t* loop, uv_run_mode mode) {
  ...
  r = uv__loop_alive(loop);
  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) {
    UV_TICK_START(loop, mode);

    uv__update_time(loop);
    uv__run_timers(loop);
    uv__run_idle(loop);
    uv__run_prepare(loop);
    uv__run_pending(loop);

    timeout = 0;
    if ((mode &amp; UV_RUN_NOWAIT) == 0)
      timeout = uv_backend_timeout(loop);

    uv__io_poll(loop, timeout);
    uv__run_check(loop);
    uv__run_closing_handles(loop);

    if (mode == UV_RUN_ONCE) {
      uv__update_time(loop);
      uv__run_timers(loop);
    }

    r = uv__loop_alive(loop);
    UV_TICK_STOP(loop, mode);

    if (mode &amp; (UV_RUN_ONCE | UV_RUN_NOWAIT))
      break;
  }
  ...
}
</code></pre>

<p>event loop的伪代码是这样的</p>

<pre><code>while there are still events to process:
    e = get the next event
    if there is a callback associated with e:
        call the callback
</code></pre>

<h3 id="section-5">异步小结</h3>
<p>Javascript的异步IO最终使用libuv, 将任务提交到线程池中进行处理. Javascript代码仍然在一条主线程中, 不需要考虑变量共享和锁的问题.</p>

<p>但是背后有多个工作线程处理异步IO操作, 使得Node.js能高校处理IO操作.</p>

<h2 id="section-6">总结</h2>

<ul>
  <li>C++能够通过v8提供的API获取并修改Javascript执行上下文</li>
  <li>暴露在Node.js环境中的系统调用最终是使用C++编写的</li>
  <li>在Node.js中调用IO接口后, 会将任务提交到线程池中执行. Node.js程序员看到的是单线程的Javascript代码, 但是最终任务是多线程处理的.<br />
<img src="/assets/node-thread-model.png" alt="thread model" /></li>
</ul>

<p>最后解答文章开头两个问题</p>

<h3 id="section-7">最大调用栈</h3>
<p>使用一部调用进行递归可以避免调用栈过深的原因是, 每次回调函数执行时候, 栈已经被清空; 只有栈清空时, event loop才有机会检测事件队列, 执行回调函数.</p>

<h3 id="section-8">队列优先级</h3>
<p>在上面已经提到, 不同的异步操作队列是有优先级的, 通常timer会高于IO操作. 当然, 前提当event loop在检测时他们都处于完成状态.</p>

<p>执行Javascript代码的v8引擎和event loop在同一个主线程上, 这导致我们使用<code>while</code>循环执行Javascript代码时, 无法检测操作状态, 直到退出<code>while</code>循环, event loop看到都已经处于完成状态的操作, 按照队列优先级执行这些操作的回调.</p>

<h2 id="section-9">相关参考</h2>

<ul>
  <li><a href="https://github.com/joyent/node/tree/v0.11.9">node</a></li>
  <li><a href="https://github.com/joyent/libuv">libuv</a></li>
  <li><a href="http://nikhilm.github.io/uvbook/">An Introduction to libuv</a></li>
  <li><a href="http://libevent.org/">libevent</a></li>
</ul>


            </article>

            <a href="https://github.com/CatTail/cattail.github.io/issues/new?title=Node.js源码阅读笔记" style="display:block; text-align:center;">
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve" fill="#888" width="60" height="60">
                    <polygon fill="none" stroke="#888" stroke-width="2" stroke-miterlimit="10" points="29,24 13,24 8,28 8,24 3,24 3,6 29,6 "/>
                    <line fill="none" stroke="#888" stroke-width="2" stroke-miterlimit="10" x1="8" y1="13" x2="24" y2="13"/>
                    <line fill="none" stroke="#888" stroke-width="2" stroke-miterlimit="10" x1="8" y1="17" x2="20" y2="17"/>
                </svg>
            </a>
          </div>
        </div>
      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    
      <p class="cc">
          <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">猫尾博客</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://cattail.me" property="cc:attributionName" rel="cc:attributionURL">Chiyu Zhong</a> 创作，<br />
          采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。
      </p>
    
    
    <p>&copy; Copyright 2013 - 2016</p>
    <p>本站由 <a href="https://upyun.com" target="_blank"><img src="/assets/upyun_logo_90x45.png" alt="upyun" style="width: 45px; vertical-align: bottom;"></a> 提供 CDN 存储服务</p>
    
  </div>
</footer>


    <link rel="stylesheet" href="/css/highlight/github-gist.css">
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
